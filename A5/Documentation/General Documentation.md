-------------------------------------------------------------------------------
# Code Generation
-------------------------------------------------------------------------------

## How code is generated by the compiler
* Code generation begins after the program passes the semantic analysis/check phase. For A5, semantic analysis was changed to calculate the lexical level of each AST node (in the AST tree) that is encountered, in addition to performing semantic checks that are performed for each program. After semantic analysis has been completed (and the machine has been initialized), the Main class then performs calls doCodeGen on the root of the AST tree to begin code generation.
	
## What classes do what
* Each node in the AST tree is an instance of a class which corresponds to the operator that they represent (e.g IdentExpn, ExitStmt, ...).Each node that is an instance of a child of the AST class (that also corresponds to an expression/statement/type/declaration) is also required to have a doCodeGen method. This doCodeGen method generates the required code for the subtree rooted at the node, which is done by (1) Generating code that performs whatever function the node serves and (2) Calling doCodeGen for any of the node's children in the AST tree.By repeating this process, the AST classes allow code to be generated through a depth first traversal of the AST tree.
	
## Changes made to our code generation strategy (since A4):
* As work on this assignment began, we decided to calculate each AST node's lexical level during the compiler's semanticCheck phase. By doing so we ensured that each scope's lexical level would always be available during code generation. In addition, the activation record was modified so that the dynamic link would always be placed below the return address, making it easier to update the display counter during clean up. 
Following A4, we have also decided to discontinue using 0 and 1 for boolean values, and to instead use MACHINE_FALSE and MACHINE_TRUE instead. 
* This made the code generation phase much less dependent on the way in which the MACHINE class handles boolean values.
* Comparison operators are no longer evaluated using double expressions. Instead, expressions like <= are computed using NOT and < operations.


------------------------------------------------------------------------------
# Note about scopes and lexical levels
In our implementation, symbol table scopes are created for the main program scope, anonymous scopes `{}`, and functions and procedures. Minor scopes of loops and if statements have no special meaning.

During code generation, main program scope starts with lexic-level of 0, anonymous scopes `{}` have the same lexic-leve and their statically containing scope, and only functions/routines have incremented lexic-level than their statically containing scope. 

So there's a slight mismatch when we talk about scopes and lexic-levels, and in our implementation are not always the same thing.

------------------------------------------------------------------------------
# Program initialization and exit
Main scope activation record is different from functions and procedures in that it doesn't contain any links or parameters.
The very first instructions executed is to get the address of the base of the main scope activation record and set `display[0]` to that address, after the program pushes two `UNDEFINED` fields (legacy problem), and execution is handed off to declarations and statements of the main scope.

Program exit is simply a `HALT` instruction, which is always the last instruction emitted.

------------------------------------------------------------------------------
# Variable declarations

Whenever a variable is declared, we record its order number in the symbol table and allocate storage with initial value of `UNDEFINED` on the stack. 
In case of arrays, we allocate as many memory locations as the size of the array.


------------------------------------------------------------------------------
# Code generation for functions and procedures
```
high address -->
				-----------------
				  local vars
				-----------------
				  parameters     (ADDR $L 5..)
				-----------------
				  static link    (ADDR $L 3)
				-----------------
				  return address (ADDR $L 2)
				-----------------
				  dynamic link   (ADDR $L 1)
				-----------------
				  return value   (ADDR $L 0)
				-----------------
low address  -->
```

## Calling a routine and creating activation record
Codes for function and procedure calls are produced from the IdentExpn (for function calls without arguments), ProcedureCallStmt, and FunctionCallStmt nodes. There's only slight variation between the code that would be generated by these nodes, all of this code has been refactored into the MachineWriter `emitCodeRoutineCall` method.

A routine call starts by creating the activation record, and evaluating the parameters (if any) and adding them to the activation record.
Note that initially we push `UNDEFINED` value for the return address until the return address is calculated, then we replace the `UNDEFINED` value with the return address. Note that we want to return to the instruction after the `BR` instruction that branched to the routine call. After the `BR` instruction is written to memory, we know the address the callee needs to return to.

## Called routine
All the called functions and procedures have their code emited by the `RoutineBody` node. Our first task is to update the `display` for the current routine. Let $L be the lexic level of the callee. We set `display[$L]` by calculating bottom of current activation record, and then following static links to get the display address of parent activation records (lower static lexical levels).

## Exit code for routines
All functions need to have a `return with` statement in all possible code paths, however for procedures if a it does not have a `return` statement as its last statement (we search the AST to make sure of this), we will add the instructions for exit code automatically.
The exit code strategy involves popping everything except the last three fields of the activation record, and then branching to the return address, which by now is on top of the stack. After branching to the caller, the stack only contains the return value, and dynamic link.

## After routine finishes executing
Let $cL be the lexical-level of the caller.
After the callee returns, we need to update the `display`. We update `display[$cL] by using dynamic link (which after routine call returns is on top of stack), and then following static links (always `ADDR $cL 3`) to update `display` for parent activation records (lower static lexical levels).

In case the callee was a procedure, the return value is `UNDEFINED` and not used, hence we pop it.
