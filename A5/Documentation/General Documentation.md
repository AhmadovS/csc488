# Documentation

------------------------------------------------------------------------------
# Code Generation

Specific implementation details are located as inline comments within the codegen methods.

## How code is generated by the compiler
* Code generation begins after the program passes the semantic analysis/check phase. For A5, semantic analysis was changed to calculate the lexical level of each AST node (in the AST tree) that is encountered, in addition to performing semantic checks that are performed for each program. After semantic analysis has been completed (and the machine has been initialized), the Main class then performs calls doCodeGen on the root of the AST tree to begin code generation.
	
## What classes do what
* Each node in the AST tree is an instance of an AST class that corresponds to the operator that it represents (e.g IdentExpn is a class that represent identity expressions, ExitStmt represents exit statements, etc). By default, each one of these AST classes is required to have a doCodeGen method. This doCodeGen method generates the required code for the subtree rooted at the node, which is done by (1) Generating code that performs whatever function the node serves. For example, calling an if statement's doCodeGen method generates the branches, comparisons and clauses required for the if statement. And (2) Calling doCodeGen for any of the node's children in the AST tree.

## Brief high level overview of the code generation process
* Code generation begins in Main.java's main method/driver, after the full AST tree has been generated and semantic analysis has been completed. As was mentioned before, semantic analysis also calculates the lexical level of each node in the AST tree, as the lexical levels are needed in code generation. 
* Main.java starts code generation by calling the doCodeGen method belonging to the AST tree's root node (i.e the main scope of the program). The doCodeGen method that gets called then generates code for initializing the main scope's activation record, before the doCodeGen method for the root's children get called. This results in the program's instructions being generated through a depth first traversal of the AST tree. It should be noted that code for operations such as exit statements can be safely generated this way, as a depth first traversal of the AST tree allows the code for all of a node A's descendants to be processed *before* the doCodeGen method for node A can exit.
	
## Changes made to our code generation strategy (since A4)
* As work on this assignment began, we decided to calculate each AST node's lexical level during the compiler's semanticCheck phase. By doing so we ensured that each scope's lexical level would always be available during code generation. In addition, the activation record was modified so that the dynamic link would always be placed below the return address, making it easier to update the display counter during clean up. 
Following A4, we have also decided to discontinue using 0 and 1 for boolean values, and to instead use MACHINE_FALSE and MACHINE_TRUE instead. 
* This made the code generation phase much less dependent on the way in which the MACHINE class handles boolean values.
* Comparison operators are no longer evaluated using double expressions. Instead, expressions like <= are computed using NOT and < operations.

## Testing
* A large number of unit tests were written to ensure that our code generator was free of any potential bugs. A list of tests can be found in tests\index.txt, and each of these tests were run at least once in order to ensure that code generation worked as intended.

------------------------------------------------------------------------------
# Note about scopes and lexical levels
In our implementation, symbol table scopes are created for the main program scope, anonymous scopes `{}`, and functions and procedures. Minor scopes of loops and if statements have no special meaning.

During code generation, main program scope starts with lexic-level of 0. Anonymous scopes `{}` have the same lexic-level as their statically containing scope, and only functions/routines have incremented lexic-level than their statically containing scope. 

So there's a slight mismatch when we talk about scopes and lexic-levels, and in our implementation are not always the same thing.

------------------------------------------------------------------------------
# Program initialization and exit
Main scope activation record is different from functions and procedures in that it doesn't contain any links or parameters.

```
Main scope activation record:
high address -->
				-----------------
				  local vars       (ADDR $L 2 ..)
				-----------------
				  RegB (UNDEFINED) (ADDR $L 1)
				-----------------
				  RegA (UNDEFINED) (ADDR $L 0)
				-----------------
low address  -->
```

The very first instructions executed is to get the address of the base of the main scope activation record and set `display[0]` to that address, after the program pushes two `UNDEFINED` fields (legacy problem), the execution is handed off to declarations and statements of the main scope (if any).

Program exit is simply a `HALT` instruction, which is always the last instruction emitted.

------------------------------------------------------------------------------
# Variable declarations

Whenever a variable is declared, we record its order number in the symbol table and allocate storage with initial value of `UNDEFINED` on the stack. 
In case of arrays, we allocate as many memory locations as the size of the array.


------------------------------------------------------------------------------
# Code generation for functions and procedures
```
high address -->
				-----------------
				  local vars
				-----------------
				  parameters     (ADDR $L 5..)
				-----------------
				  static link    (ADDR $L 3)
				-----------------
				  return address (ADDR $L 2)
				-----------------
				  dynamic link   (ADDR $L 1)
				-----------------
				  return value   (ADDR $L 0)
				-----------------
low address  -->
```

## Calling a routine and creating activation record
Codes for function and procedure calls are produced from the IdentExpn (for function calls without arguments), ProcedureCallStmt, and FunctionCallStmt nodes. There's only slight variation between the code that would be generated by these nodes, all of this code has been refactored into the MachineWriter `emitCodeRoutineCall` method.

A routine call starts by creating the activation record, and evaluating the parameters (if any) and adding them to the activation record.
Note that initially we push `UNDEFINED` value for the return address until the return address is calculated. Note that we want to return to the instruction after the `BR` instruction of the caller that branched to the routine call. After the `BR` instruction is written to memory, we know the address the callee needs to return to, we can then replace the `UNDEFINED` value for the return address.

## Called routine
All the called functions and procedures have their code emited by the `RoutineBody` node. Our first task is to update the `display` for the current routine. Let $L be the lexic level of the callee. We set `display[$L]` by calculating bottom of current activation record, and then following static links to get the display address of parent activation records (lower static lexical levels).

## Exit code for routines
All functions need to have a `return with` statement in all possible code paths, however for procedures, if we see it does not have a `return` statement as its last statement (we search the AST to make sure of this), we will add the instructions for exit code automatically.
The exit code strategy involves popping everything except the last three fields of the activation record, and then branching to the return address, which by now is on top of the stack. After branching to the caller, the stack only contains the return value, and dynamic link.

## After routine finishes executing
Let $cL be the lexical-level of the caller.
After the callee returns, we need to update the `display`. We update `display[$cL]` by using dynamic link (which after routine call returns is on top of stack), and then following static links (always `ADDR $cL 3`) to update `display` for parent activation records (lower static lexical levels).

In case the callee was a procedure, the return value is `UNDEFINED` and not used, hence we pop it.
