-------------------------------------------------------------------------------
	Code Generation
-------------------------------------------------------------------------------

How code is generated by the compiler:
	- Code generation begins after the program passes the semantic analysis/check phase. For A5, 
	semantic analysis was changed to calculate the lexical level of each AST node (in the AST tree) that is 
	encountered, in addition to performing semantic checks that are performed for each program. 
	After semantic analysis has been completed (and the machine has been initialized), the Main class 
	then performs calls doCodeGen on the root of the AST tree to begin code generation.
	
What classes do what:
	- Each node in the AST tree is an instance of a class which corresponds to the operator that they represent (e.g IdentExpn, ExitStmt, ...).
	Each node that is an instance of a child of the AST class (that also corresponds to an expression/statement/type/declaration) is 
	also required to have a doCodeGen method. This doCodeGen method generates the required code for the subtree rooted at the node, which is done
	by (1) Generating code that performs whatever function the node serves and (2) Calling doCodeGen for any of the node's children in the AST tree.
	By repeating this process, the AST classes allow code to be generated through a depth first traversal of the AST tree.
	
Changes made to our code generation strategy (since A4):
	- As work on this assignment began, we decided to calculate each AST node's lexical level during the compiler's semanticCheck phase. Doing so would
	ensure that each node's lexical level would always be available during code generation. In addition, the activation record was modified so that the 
	dynamic link would always be placed below the return address, making it easier to update the display counter as a functional call is being cleaned up.
	Therefore, the bottommost portion of a major scope's activation record currently appears as shown below:
high address -->
				-----------------
				  static link
				-----------------
				  return address
				-----------------
				  dynamic link
				-----------------
				  return value
				-----------------
low address  -->

	- Following A4, we have also decided to discontinue using 0 and 1 for boolean values, and to instead use MACHINE_FALSE and MACHINE_TRUE instead. 
	This made the code generation phase much less dependent on the way in which the MACHINE class handles boolean values.
	