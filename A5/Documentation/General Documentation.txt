-------------------------------------------------------------------------------
	Code Generation
-------------------------------------------------------------------------------

How code is generated by the compiler:
	- Code generation begins after the program passes the semantic analysis/check phase. For A5, 
	semantic analysis was changed to calculate the lexical level of each AST node (in the AST tree) that is 
	encountered, in addition to performing semantic checks that are performed for each program. 
	After semantic analysis has been completed (and the machine has been initialized), the Main class 
	then performs calls doCodeGen on the root of the AST tree to begin code generation.
	
What classes do what:
	- Each node in the AST tree is an instance of a class which corresponds to the operator that they represent (e.g IdentExpn, ExitStmt, ...).
	Each node that is an instance of a child of the AST class (that also corresponds to an expression/statement/type/declaration) is 
	also required to have a doCodeGen method. This doCodeGen method generates the required code for the subtree rooted at the node, which is done
	by (1) Generating code that performs whatever function the node serves and (2) Calling doCodeGen for any of the node's children in the AST tree.
	By repeating this process, the AST classes allow code to be generated through a depth first traversal of the AST tree.
	
Changes made to our code generation strategy (since A4):
	- As work on this assignment began, we decided to calculate each AST node's lexical level during the compiler's semanticCheck phase. Doing so would
	ensure that each node's lexical level would always be available during code generation. In addition, the activation record was modified so that the 
	dynamic link would always be placed below the return address, making it easier to update the display counter as a functional call is being cleaned up.
	Therefore, the bottommost portion of a major scope's activation record currently appears as shown below:
high address -->
				-----------------
				  static link
				-----------------
				  return address
				-----------------
				  dynamic link
				-----------------
				  return value
				-----------------
low address  -->

	- Following A4, we have also decided to discontinue using 0 and 1 for boolean values, and to instead use MACHINE_FALSE and MACHINE_TRUE instead. 
	This made the code generation phase much less dependent on the way in which the MACHINE class handles boolean values.
	

------------------------------------------------------------------------------
# Code generation for functions and procedures

high address -->
				-----------------
				  static link
				-----------------
				  return address
				-----------------
				  dynamic link
				-----------------
				  return value
				-----------------
low address  -->

## Calling a routine and creating activation record
Functions and procedures are called only from the IdentExpn, ProcedureCallStmt, and FunctionCallStmt nodes. There's only slight variation between the code that would be generated by these nodes, all of this code has been refactored into the MachineWriter class `emitCodeRoutineCall` method.

A routine call starts by creating the activation record, and evaluating the parameters if any and also adding them to the activation record.
Note that we push `UNDEFINED` value for the return address, until the return address is calculated (we want to return to the instruction after the `BR` instruction that branched to the routine call, after the `BR` instruction is written to memory, we know the address of the return address).

## Called routine
All functions and procedures that are called, have the same template as defined in `RoutineBody` node. Our first task is to update the display for the current routine, by calculating bottom of current activation record, and following static links to get the display address of parent activation records (lower static lexical levels).

## Exit code for routines
All functions need to have a `return with` statement in all possible code paths, however if a procedure does not have a `return` statement as its last statement (we search the AST to make sure of this), we will add the instructions for exit code automatically.
The exit code strategy involves popping everything except the last three fields of the activation record, and then branching to the return address, which by now is on top of the stack. After branching to the caller, the stack only contains the return value, and dynamic link.

## After routine finishes executing
After the callee returns, we need to update the `display` by using the value stored in the dynamic link (which after routine call returns is on top of stack), and then following static links to update `display` for parent activation records (lower static lexical levels).

If the callee was also a procedure, we will pop the `UNDEFINED` return value that is now on top of the stack, otherwise the return value is used as part of an expression.
